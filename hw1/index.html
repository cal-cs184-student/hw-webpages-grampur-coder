<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 1 Write-Up</h1>
		<div style="text-align: center;">Names: </div>

		<br>

		Link to webpage: <a href="https://cal-cs184-student.github.io/hw-webpages-grampur-coder/hw1/index.html">cs184.eecs.berkeley.edu/sp25</a>
		
		<br>

		Link to GitHub repository:  <a href="https://github.com/cal-cs184-student/hw-webpages-grampur-coder">cs184.eecs.berkeley.edu/sp25</a>

		<figure>
			<img src="lion.jpg" alt="Lion" style="width:50%"/>
			<figcaption>You can add images with captions!</figcaption>
		</figure>

		<!--
		We've already added one heading per task, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
			Homework 1 
		<h2>Task 1: Drawing Single-Color Triangles</h2>

		<ol>
		  <li>
			<p><b>How to rasterize.</b></p>
			<ul>
			  <li>The idea is that a triangle covers a pixel if the pixel's center lies in the triangle.</li>
			  <li>the pixel center for a pixel at (x,y) = (x+0.5, y+0.5), For each triangle edge, check which side the point lies on.</li>
		
			  <li>By the spec, we only needed to test pixels near the triangle.</li>
			  <li>Then, I used the edge lambda function I defined, which told me the orientation.</li>
			  <li>Now if all 3 edge values are &gt;= 0 or all 3 are &lt;= 0then we are inside.</li>
			  <li>Finally we just call the fill pixel function if that pixel belongs inside the triangle.</li>
			</ul>
		  </li>
		
		  <li>
			<p><b>How the algorithm comapres</b></p>
			<ul>
			  <li>My algorithm only iterates over pixels who lie inside that bounding box because it first computes the triangle’s axis-aligned bounding box.</li>
			  <li>It doesn't scan the full framebuffer.</li>
			</ul>
		  </li>
		</ol>
		
		<p>test4.</p>
		
		<div style="display: flex; flex-direction: column; align-items: center;">
		  <table style="width: 100%; text-align: center; border-collapse: collapse;">
			<tr>
			  <td style="text-align: center;">
				<img src="test4.png" width="400px"/>
				<figcaption>Test 4.</figcaption>
			  </td>
			</tr>
		  </table>
		</div>
		
		<h2>Task 2: Antialiasing by Supersampling</h2>

		<ol>
		  <li>
			<b>Supersampling algorithm and data structures.</b><br>
			I basically changed it so instead of storing one color per pixel, I store a bunch of samples per pixel.
			I use <code>sample_buffer</code> sized <code>width × height × sample_rate</code>. Each pixel gets a
			√sample_rate by √sample_rate grid of sub samples. When I rasterize a triangle I check every sub-sample
			spot inside the pixel and if its inside the triangle I write the color into that sub sample slot.
		  </li>
		
		  <li>
			<b>Why supersampling is useful.</b><br>
			Supersampling helps fix the jagged edges on triangles. With only one sample per pixel its like all or
			nothing, so edges look stair-steppy. With more samples per pixel you can get partial coverage and when
			you average them it looks way smoother.
		  </li>
		
		  <li>
			<b>Modifications to the rasterization pipeline.</b><br>
			I resized the sample buffer whenever the framebuffer size or sample rate changes, updated
			<code>rasterize_triangle</code> to loop over sub samples instead of just the center, changed
			<code>fill_pixel</code> so points and lines just fill every sub sample in that pixel, and then changed
			<code>resolve_to_framebuffer</code> to average all the sub samples into the final color.
		  </li>
		
		  <li>
			<b>How supersampling antialiases triangles.</b><br>
			For each pixel in the triangle bounding box I test all the sub sample positions with the same edge test.
			The ones inside get colored, the others stay background. Then at the end I average them together, so edge
			pixels end up partially filled instead of fully on/off, which is why the triangle edges look smoother.
		  </li>
		</ol>

<div style="display:flex; gap:20px; justify-content:center;">
  <figure>
    <img src="test4_1.png" width="300">
    <figcaption>Sample rate = 1</figcaption>
  </figure>

  <figure>
    <img src="test4_4.png" width="300">
    <figcaption>Sample rate = 4</figcaption>
  </figure>

  <figure>
    <img src="test4_16.png" width="300">
    <figcaption>Sample rate = 16</figcaption>
  </figure>
</div>


		<h2>Task 3: Transforms</h2>
		1. For this task I just made the robot wave his arm. 
		<figure style="text-align:center;">
			<img src="robot.png" width="400">
			<figcaption>My waving robot render.</figcaption>
		  </figure>

		  <h2>Task 4: Barycentric Coordinates</h2>

		  <ol>
			<li>
			  <b>What barycentric coordinates are.</b><br>
			  Barycentric coordinates are basically just weights for the three vertices of a triangle.
			  For any point inside the triangle you get 3 numbers (w0, w1, w2) that add up to 1.
			  If the point is closer to one vertex then that vertex’s weight is bigger.
			  On a vertex its weight is 1 and the other two are 0.
			</li>
		  
			<li>
			  <b>How I use them for color interpolation.</b><br>
			  Each vertex has a color, like red, green, and blue.
			  Then for a point inside the triangle I just do:
			  <code>color = w0*c0 + w1*c1 + w2*c2</code>.
			  So the color smoothly blends depending on where you are.
			  Near the red corner its mostly red, near green its mostly green, etc.
			</li>
		  
			<li>
			  <b>Image example.</b><br>
			  This triangle shows one red, one green, and one blue vertex.
			  You can see how the inside just smoothly blends between them.
			</li>
		  </ol>
		  
		  <div style="display:flex; gap:20px; justify-content:center;">
			<figure style="text-align:center;">
			  <img src="triangle.png" width="300">
			  <figcaption>RGB vertex triangle.</figcaption>
			</figure>
		  
			<figure style="text-align:center;">
			  <img src="circle.png" width="300">
			  <figcaption>basic/test7.svg</figcaption>
			</figure>
		  </div>
		  

		  
		  <h2>Task 5: Pixel sampling for texture mapping</h2>

		  <ol>
			<li>
			  <b>What pixel sampling is (in my words).</b><br>
			  Pixel sampling is basically: once i know a screen sample is inside the triangle, i map that point to a (u,v)
			  coordinate on the texture, and then i need to decide what color to grab from the texture image.
			  Like uv is usually not landing exactly on a texel, so sampling is just how we pick the final color.
			</li>
		  
			<li>
			  <b>How I implemented texture mapping.</b><br>
			  For each triangle sample (and each subsample when sample_rate &gt; 1), i compute barycentric coords, use those to
			  interpolate the triangle’s (u,v), then i call <code>tex.sample</code> with my <code>SampleParams</code>.
			  The GUI toggle with <code>P</code> changes <code>psm</code> so it switches between nearest vs bilinear.
			  Then i write that color into the correct slot in <code>sample_buffer</code> and resolve like normal by averaging.
			</li>
		  
			<li>
			  <b>Nearest vs Bilinear .</b><br>
			  <ul>
				<li>
				  <b>Nearest:</b> just picks the closest texel (one pixel in the texture). it’s fast but it looks blocky,
				  especially when the texture is zoomed in or rotated.
				</li>
				<li>
				  <b>Bilinear:</b> takes the 4 surrounding texels and blends them. it’s smoother because it doesn’t do those
				  hard jumps between texels.
				</li>
			  </ul>
			</li>
		  
			<li>
			  <b>Where bilinear clearly beats nearest.</b><br>
			  I looked in <code>svg/texmap/</code> and used the pixel inspector on a spot where the texture is at a slant /
			  shrinking so you get lots of “in-between” uv coords. Nearest looks super chunky there, but bilinear looks way smoother.
			</li>
		  </ol>
		  
		  <p>
		  Below are the 4 screenshots they asked for (same view / same pixel inspector area):
		  </p>
		  
		  <div style="display:flex; flex-wrap:wrap; gap:20px; justify-content:center; align-items:flex-start;">
			<figure style="text-align:center;">
			  <img src="pixel_1.png" width="320" alt="Nearest sampling, 1 sample per pixel">
			  <figcaption>Nearest, sample rate = 1</figcaption>
			</figure>
		  
			<figure style="text-align:center;">
			  <img src="pixel_16.png" width="320" alt="Nearest sampling, 16 samples per pixel">
			  <figcaption>Nearest, sample rate = 16</figcaption>
			</figure>
		  
			<figure style="text-align:center;">
			  <img src="bilinear_1.png" width="320" alt="Bilinear sampling, 1 sample per pixel">
			  <figcaption>Bilinear, sample rate = 1</figcaption>
			</figure>
		  
			<figure style="text-align:center;">
			  <img src="bilinear_16.png" width="320" alt="Bilinear sampling, 16 samples per pixel">
			  <figcaption>Bilinear, sample rate = 16</figcaption>
			</figure>
		  </div>
		  
		  <p>
		  <b>Comments / differences:</b><br>
 The biggest difference between nearest and bilinear happens when the texture is being
		  magnified a lot, or it’s at an angle / shrinking so the uv coords land between texels constantly.
		  </p>
		  
		  <h2>Task 6: Level Sampling with mipmaps for texture mapping</h2>

		  Level sampling is just picking which mipmap level to sample from. Like if the texture is getting shrunk a lot on the screen, sampling from the full res image is gonna alias and shimmer because too much detail is getting crammed into one pixel. So mipmaps are just smaller and smaller copies of the same texture, and level sampling is choosing the right sized copy for the current zoom.
		  
		  How I implemented it for texture mapping was:
		  First I built the mipmap pyramid. Level 0 is the original texture. Then each next level is half the width and half the height until it hits 1 by 1. Each mip level is made by downsampling the previous level using a simple average of a 2 by 2 block into one pixel.
		  
		  Then when I sample the texture for a pixel, I compute how “big” the pixel footprint is in texture space using the uv derivatives. The renderer gives me uv for the current sample plus uv for moving one pixel in x and one pixel in y. I use that to estimate how fast u and v are changing across the screen. If uv changes a lot across 1 screen pixel, that means the texture is being minified hard so I should use a higher mip level. If uv changes only a tiny amount, then level 0 is fine.
		  
		  Concretely I do this:
		  I convert the uv step sizes into texel units by multiplying by the texture width and height. Then I take the max of the two step magnitudes as the footprint size. Then level is log base 2 of that footprint. After that I clamp the level to the valid range.
		  
		  For L_ZERO I just force the level to 0 every time.
		  For L_NEAREST I pick the nearest mip level index from the computed level and sample from that mipmap image.
		  
		  After the level is chosen, pixel sampling happens inside that mip level.
		  P_NEAREST grabs the closest texel.
		  P_LINEAR does bilinear interpolation using the 4 surrounding texels.
		  
		  </br>
		  
		  <h2>Tradeoffs between pixel sampling, level sampling, and samples per pixel</h2>
		  
		  There are 3 different knobs that affect quality and performance.
		  
		  <b>Pixel sampling</b><br>
		  P_NEAREST is the fastest because it is one lookup.
		  P_LINEAR is slower because it reads 4 texels and blends them.
		  Memory is basically the same for both.
		  Quality wise P_LINEAR looks smoother up close, but it does not fix the big problem when the texture is zoomed out. It can still shimmer since you are still sampling from a texture that has way too much detail for the pixel.
		  
		  <b>Level sampling</b><br>
		  L_ZERO is fastest and uses the least memory because it always samples level 0 and you do not need mipmaps.
		  L_NEAREST is a bit slower because you compute the mip level and you sample from a mipmap.
		  Memory goes up because mipmaps store extra images. It is around one third more memory than the base texture.
		  Quality wise this is the big win for minification. It reduces moiré and that crawling shimmer a lot because you are sampling from a lower detail version that matches the pixel footprint.
		  
		  <b>Number of samples per pixel</b><br>
		  More samples per pixel is the slowest because you are doing multiple evaluations per pixel. Like 4 samples per pixel is basically around 4 times the work.
		  Memory can go up a bit depending on implementation, but mostly it is compute expensive.
		  Quality wise it is the strongest overall anti aliasing because it helps both texture aliasing and geometry edge aliasing. It is like brute force averaging.
		  
		  So the vibe is:
		  Pixel sampling helps smooth inside one texture level.
		  Level sampling fixes zoomed out texture aliasing.
		  More samples per pixel gives the best anti aliasing overall but costs the most time.
		  
		  </br>
		  
		  <h2>Four versions using my png and the required combos</h2>
		  
		  I picked a png that has thin lines and sharp high frequency patterns so the differences show up clearly when zooming out.
		  
		  To use my png I copied one of the svg files in svg texmap and changed the texture filename near the top to point to my png. Then I ran ./draw with that svg. For each setting combo I used the S hotkey to save screenshots.
		  
		  What I see in the results:
		  L_ZERO and P_NEAREST looks the worst. was kind of jagged.
		  L_ZERO and P_LINEAR is smoother up close but still shimmers when zoomed out.
		  L_NEAREST and P_NEAREST is way more stable but still kind of crunchy.
		  L_NEAREST and P_LINEAR is the best here. stable and smooth and least moiré.
		  I did a 16 supersampling rate for all.
		  
		  <div style="display:grid; grid-template-columns: 1fr 1fr; gap: 12px;">
			<div>
			  <p><b>L_ZERO and P_NEAREST</b></p>
			  <img src="zeroandnear.png" width="100%">
			</div>
			<div>
			  <p><b>L_ZERO and P_LINEAR</b></p>
			  <img src="zeroandlinear.png" width="100%">
			</div>
			<div>
			  <p><b>L_NEAREST and P_NEAREST</b></p>
			  <img src="nearandnear.png" width="100%">
			</div>
			<div>
			  <p><b>L_NEAREST and P_LINEAR</b></p>
			  <img src="nearandlinear.png" width="100%">
			</div>
		  </div>
		  
		  </br>
		  
		</div>
	</body>
</html>